= Cross platform applications with Scala Native
:source-highlighter: highlightjs
:highlightjs-languages: scala
:highlightjs-theme: css/solarized-dark.css
:revealjs_theme: moon
:revealjs_hash: true
:customcss: css/presentation.css
:icons: font

image::images/fs2-logo.png[]

== Agenda
- hexdump4s
- intro to scala native
- udp-replay
- libpcap
- tcpdump4s

=== Hex Dumps

image::images/print-hex-dump.png[]

=== CLI Hex Dumps

[source,scala]
----
//> using scala "3.2.0"
//> using lib "org.scodec::scodec-bits::1.1.34"
//> using lib "com.monovore::decline::2.3.1"
----

=== CLI Hex Dumps

[source,scala]
----
val command = Command(
  name = "hexdump4s",
  header = "Prints a hex dump of a file"
) {
  val offset = Opts.option[Long](
    "offset", short = "s", metavar = "count",
    help = "Number of bytes to skip at start of input"
  ).withDefault(0L)
  val length = Opts.option[Long](
    "length", short = "n", metavar = "count",
    help = "Number of bytes to dump").orNone
  val noColor = Opts.flag(
    "no-color", help = "Disables color ouptut").orFalse
  val file = Opts.argument[Path](metavar = "file").orNone
  (offset, length, noColor, file).tupled
}
----

=== CLI Hex Dumps

[source,scala]
----
command.parse(args) match
  case Left(help) =>
    System.err.println(help)
  case Right((offset, limit, noColor, file)) =>
    def data: BitVector =
      val source = BitVector.fromInputStream(
        file.map(f => Files.newInputStream(f))
            .getOrElse(System.in))
      source.drop(offset * 8L)
    HexDumpFormat.Default
      .withAnsi(!noColor)
      .withAddressOffset(offset.toInt)
      .withLengthLimit(limit.getOrElse(Long.MaxValue))
      .print(data)
----

=== CLI Hex Dumps

[source]
----
➜  scala-cli hexdump4s.sc -- -help
Usage: hexdump4s [--offset <count>] [--length <count>] [--no-color] [<file>]

Prints a hex dump of a file

Options and flags:
    --help
        Display this help text.
    --offset <count>, -s <count>
        Number of bytes to skip at start of input
    --length <count>, -n <count>
        Number of bytes to dump
    --no-color
        Disables color ouptut
----

=== CLI Hex Dumps

image::images/hexdump-cli.png[]

=== Packaging as JVM App

[source]
----
➜  scala-cli package hexdump4s.sc -o hexdump4s -f --assembly

➜  du -h hexdump4s
 17M	hexdump4s
----

=== Packaging as JVM App

[source]
----
➜  time ./hexdump4s LICENSE > /dev/null

________________________________________________________
Executed in  810.57 millis    fish           external
   usr time  925.87 millis    0.24 millis  925.64 millis
   sys time  157.68 millis    6.49 millis  151.19 millis
----

=== Packaging as Native App

Optimizing ahead-of-time compiler via LLVM

[source]
----
➜  scala-cli package --native hexdump4s.sc -o hexdump4s -f

➜  du -h hexdump4s
8.3M	hexdump4s

➜  time ./hexdump4s LICENSE > /dev/null

________________________________________________________
Executed in   61.50 millis    fish           external
   usr time   35.84 millis    0.20 millis   35.63 millis
   sys time   20.09 millis    5.10 millis   14.99 millis
----

=== Packaging as GraalVM Native Image

[source]
----
➜  scala-cli package --native-image hexdump4s.sc -f -- --no-fallback

➜  du -h hexdump4s
 17M	hexdump4s

➜  time ./hexdump4s LICENSE > /dev/null

________________________________________________________
Executed in  156.47 millis    fish           external
   usr time  127.23 millis    0.06 millis  127.17 millis
   sys time   19.13 millis    1.09 millis   18.04 millis
----

== Scala Native

- Ahead of time compiler for Scala
- Supports structs, stack & heap allocation, and pointers
- Painless interop with native code
- No multithreading (yet?)
- Supports Scala 2.11, 2.12, 2.13, and 3

[%notitle]
== tcpdump4s

image::images/tcpdump4s.png[]

=== tcpdump4s: Command Line Interface

[source,scala]
----
val command = Command("tcpdump4s", "Network packet captures") {
  val showInterfacesOpt = Opts.flag("interfaces", "shows network interfaces supporting packet capture")
                              .as(showInterfaces)

  val captureOpt =
    val interface = Opts.option[String]("interface", short = "i", help = "name of the interface to capture on")
    val expression = Opts.argument[String](metavar = "expression").orNone
    (interface, expression).mapN(capture)

  showInterfacesOpt orElse captureOpt
}

def showInterfaces: IO[Unit] = ???
def capture(interface: String,
            expression: Option[String]): IO[Unit] = ???
----

=== tcpdump4s main

[source,scala]
----
object Main extends IOApp: <1>
  def run(args: List[String]) =
    command.parse(args) match
      case Left(help) => IO(System.err.println(help))
                           .as(ExitCode(-1))
      case Right(prg) => prg.as(ExitCode.Success)
----
<1> Cats Effect for Scala Native ships with an `IOApp` runtime that uses a single threaded event loop

== showInterfaces

[source,scala]
----
def showInterfaces: IO[Unit] = ???
  // Get all interfaces
  // Filter to only the up & running ones
  // Print the name of the interface and each assigned address
----

=== Pcap.interfaces

[source,scala]
----
/** Provides a high level, functional interface for libpcap. */
object Pcap:
  case class Interface(
    name: String,
    description: String, 
    addresses: List[Address],
    flags: InterfaceFlags)

  def interfaces: IO[List[Interface]] = ???
----

[%notitle]
=== Pcap.interfaces

[source,c]
----
#include <pcap/pcap.h>

char errbuf[PCAP_ERRBUF_SIZE];

int pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf);
void pcap_freealldevs(pcap_if_t *alldevs);
----

[%notitle]
=== Pcap.interfaces

[source,c]
----
typedef struct pcap_if pcap_if_t;

struct pcap_if {
	struct pcap_if *next;
	char *name;		/* name to hand to "pcap_open_live()" */
	char *description;	/* textual description of interface, or NULL */
	struct pcap_addr *addresses;
	bpf_u_int32 flags;	/* PCAP_IF_ interface flags */
};
----

[%step]
[source,scala]
----
/** Exposes libpcap API via Scala Native. */
object libpcap:
  opaque type pcap_if = CStruct5[Ptr[Byte], CString, CString, Ptr[Byte], CUnsignedInt]
  object pcap_if:
    given _tag: Tag[pcap_if] = Tag.materializeCStruct5Tag[Ptr[Byte], CString, CString, Ptr[Byte], CUnsignedInt]
    extension (struct: pcap_if)
      def next: Ptr[pcap_if] = struct._1.asInstanceOf[Ptr[pcap_if]]
      def name: CString = struct._2
      def description: CString = struct._3
      def addresses: Ptr[pcap_addr] = struct._4.asInstanceOf[Ptr[pcap_addr]]
      def flags: CUnsignedInt = struct._5
----

=== CStructN

TODO

- C-aligned struct of N element types
- Positional access
- opaque type + extension method pattern
- tags

== tcpdump4s: capture

TODO